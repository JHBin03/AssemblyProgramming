# x86 Processor architecture
## x86 어셈블리 언어의 이해를 위한 핵심 요소
  이 다섯 가지 요소는 서로 밀접하게 연결되어 있으며, 하나가 다음 단계에 영향을 미치는 순환 구조를 이루어 컴퓨터 시스템의 동작 원리를 설명한다.
### 프로세서 아키텍처 (Processor Architecture)
- 프로세서(CPU)의 내부 구조와 능력을 의미한다.
### 명령어 실행
- 프로세서 내에서 명령어를 수행하는 과정
### 프로그램 로딩
- 운영체제가 프로그램을 메모리로 불러오는 방법 
### 메인보드 레이아웃
- 메인보드에 부품이 물리적으로 배치된 배열
### 입/출력 작업
- 애플리케이션과 운영체제 간의 계층화된 통신

## 메인 메모리 내부의 부품들 간의 관계
네, 요청하신 내용을 Markdown 형식의 표로 정리해 드립니다.

## 컴퓨터 주요 구성 요소 간의 관계

| 구성 요소 | 역할 | 관계의 핵심 |
| :--- | :--- | :--- |
| **CPU (중앙 처리 장치)** | 컴퓨터의 **두뇌**. 명령어 해석 및 실행. | 메인 메모리에서 명령과 데이터를 가져와 **레지스터**에서 처리한 후 결과를 메모리에 다시 기록 (**읽고-처리하고-쓰기**의 중심). |
| **레지스터 (Register)** | CPU 내부의 **초고속 임시 저장소**. | CPU가 연산을 수행하는 데 있어 **가장 직접적인 작업 공간**. 메모리보다 훨씬 빠름. |
| **주기억장치 (RAM)** | 현재 실행 중인 프로그램의 **명령어와 데이터를 저장** (휘발성). | CPU에게 **작업할 대상(명령과 데이터)**을 제공하는 장소. |
| **보조기억장치 (SSD/HDD)** | 프로그램과 데이터를 **영구적으로 저장** (비휘발성). | 주기억장치에 **실행할 프로그램**을 공급하는 원천. |
| **메인보드/버스** | 모든 부품을 연결하는 **물리적 경로 및 통신 통로**. | CPU, RAM, 보조기억장치 등 핵심 부품 간의 **데이터 이동**을 중재하고 지원함. |

### ALU
- 산술연산을 한다.
- 덧셈기 밖에 없기 때문에 보수 개념을 이용해야 뺄셈을 할 수 있다.
- 곱셈 : 덧셈의 반복, 나눗셈 : 뺄셈의 반복

## CPU 명령어 실행 순서
### 1. 명령어 인출 
- CPU가 메모리에서 실행할 명령어를 가져온다.
### 2. 명령어 포인터 증가
- CPU는 다음 명령어를 가져올 위치를 가리키는 포인터(주소)를 업데이트한다.
### 3. 명령어 해석
- CPU는 가져온 명령어의 **이진 패턴(Binary Pattern)**을 분석하여 어떤 연산을 수행해야 하는지, 필요한 데이터(Operand)는 무엇인지 해석한다.
### 4. 오퍼랜드 인출
- 명령어 실행에 필요한 **데이터(오퍼랜드)**를 레지스터나 메모리에서 가져온다.
### 5. 명령어 실행
-  CPU는 인출한 데이터(오퍼랜드)를 사용하여 실제 연산을 수행
### 6. 결과 저장 및 상태 플래그 업데이트
- 상태 플래그 업데이트: 연산 결과에 따라 Zero, Carry, Overflow와 같은 CPU 내부의 상태 플래그를 업데이트
- 결과 저장: CPU는 연산 결과를 **출력 데이터(Output Operand)**가 지정하는 위치(레지스터 또는 메모리)에 저장
### 이후 CPU는 다시 1단계로 돌아가 다음 명령어를 인출하며 이 과정을 반복한다.

## Decode와 Operationi Code
### OPCode
- 컴퓨터의 **명령어(Instruction)**에서 **'무엇을 할 것인가'**를 지정하는 이진 비트들의 집합
- 일반적인 기계어 명령어는 크게 **Op코드(연산자 부)**와 **오퍼랜드(Operand, 피연산자 부)**로 나뉜다.
- CPU의 제어 장치(Control Unit)가 메모리에서 명령어를 가져왔을 때, 이 Op코드를 보고 해당 명령을 실행하는 데 필요한 일련의 마이크로 연산을 발생시킨다.
### Decode
- PU의 명령어 사이클(Instruction Cycle) 중 두 번째 단계로, 가져온 명령어를 해석하는 과정을 의미한다.
- 메모리에서 인출한 이진 형태의 명령어를 **제어 장치(Control Unit)**가 분석하여, 해당 명령이 정확히 어떤 동작을 요구하는지, 그리고 그 동작을 수행하는 데 필요한 데이터(오퍼랜드)는 어디에 있는지를 파악하는 과정
- 디코드는 명령어 전체를 분석하는 과정이며, 특히 명령어의 Op코드 부분을 해독한다.

## C언어와 Java의 메모리 구조 차이
### C 언어의 메모리 구조
C 프로그램이 실행되면 운영체제로부터 할당받는 메모리 영역은 보통 네 가지로 나뉜다.
- 1. 코드 영역 (Code/Text Segment): 실행할 프로그램 코드가 기계어 형태로 저장.
- 2. 데이터 영역 (Data Segment): 전역 변수와 static 변수가 저장.
- 3. 힙 영역 (Heap): malloc이나 calloc을 통해 동적으로 할당되는 영역이며, 크기가 가변적
- 4. 스택 영역 (Stack): 함수 호출 시 생성되는 지역 변수와 매개변수, 함수 종료 후 돌아갈 주소 등이 저장되며, 함수 호출 시마다 Stack Frame이 쌓인다.
### Java의 메모리 구조
- OS 위에 있는 JVM이 메모리를 관리하며, 이 공간을 **JVM 런타임 데이터 영역(Runtime Data Area)**이라고 부른다. 이는 스레드 공유 영역과 스레드 전용 영역으로 나뉜다.

| 특징 | C 언어 | Java |
| :--- | :--- | :--- |
| **실행 환경** | OS 위에서 직접 실행 (플랫폼 종속적) | **JVM** 위에서 실행 (플랫폼 독립적) |
| **메모리 접근** | **직접적** (**포인터** 사용 가능) | **간접적** (JVM을 통해 메모리 추상화) |
| **안정성/성능** | 메모리 직접 제어로 **성능**이 우수하나, 오류 발생 시 **안정성**이 낮음 | 자동 **GC**로 **안정성**이 높으나, GC 오버헤드로 인해 C보다 상대적으로 **느림** |
| **동적 객체 위치** | `malloc` 등으로 할당 시 **Heap** | `new` 연산자로 생성 시 **Heap** |
