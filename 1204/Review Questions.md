# Review Questions

1. (What is the purpose of the STRUCT directive?)
(STRUCT 지시어는 여러 개의 관련된 변수를 하나의 구조체 타입으로 정의하는 데 사용한다.)
---------
2. (State whether or not each of the following declarations is valid.)
 a는 잘못된 선언이다.
 b는 올바른 선언이다.
 c는 올바른 선언이다.
 d는 올바른 선언이다.
 e는 올바른 선언이다.
---------
3. ((True/False) A macro cannot contain data definitions.)
(거짓이다.)
---------
4. (What is the purpose of the LOCAL directive?)
(LOCAL 지시어는 매크로 내부 라벨의 중복 충돌을 방지하기 위해 고유한 라벨을 생성하는 데 사용한다.)
---------
5. (Which directive displays a message on the console during the assembly step?)
(ECHO 지시어가 어셈블 단계에서 메시지를 출력한다.)
---------
6. (Which directive marks the end of a conditional block of statements?)
(ENDIF 지시어가 조건부 블록의 끝을 표시한다.)
---------
7. (List all the relational operators that can be used in constant boolean expressions.)
(LT, LE, GT, GE, EQ, NE 연산자를 사용한다.)
---------
8. (What is the purpose of the & operator in a macro definition?)
(& 연산자는 매크로 매개변수 이름의 모호한 참조를 명확하게 치환하는 데 사용한다.)
---------
9. (What is the purpose of the ! operator in a macro definition?)
(! 연산자는 특수 연산자를 일반 문자로 처리하도록 강제하는 데 사용한다.)
---------
10. (What is the purpose of the % operator in a macro definition?)
(% 연산자는 텍스트 매크로나 상수 표현식을 실제 값으로 확장하는 데 사용한다.)
---------


# Algorithm Workbench

1. (Create a structure named SampleStruct containing two fields: field1, a single 16-bit WORD, and field2, an array of 20 32-bit DWORDs.)
(SampleStruct STRUCT
 field1 WORD ?
 field2 DWORD 20 DUP(?)
 SampleStruct ENDS 로 정의한다.)
---------
2. (Write a statement that retrieves the wHour field of a SYSTEMTIME structure.)
(mov ax, sysTime.wHour 로 값을 가져온다.)
---------
3. (Declare a Triangle structure variable and initialize its vertices to (0,0), (5,0), and (7,6).)
(myTri Triangle < <0,0>, <5,0>, <7,6> > 로 선언한다.)
---------
4. (Declare an array of Triangle structures and write a loop that initializes Vertex1 of each triangle to random coordinates in the range (0…10, 0…10).)
(Triangle 배열을 선언하고 반복문과 RandomRange를 사용하여 각 Vertex1.X와 Vertex1.Y를 0~10 범위로 초기화한다.)
---------
5. (Write a macro named mPrintChar that displays a single character on the screen.)
(mPrintChar MACRO ch, count
 LOCAL L1
 mov ecx,count
L1:
 mov al,ch
 call WriteChar
 loop L1
 ENDM 로 정의한다.)
---------
6. (Write a macro named GenRandom that generates a random integer between 0 and n−1.)
(GenRandom MACRO n
 mov eax,n
 call RandomRange
 ENDM 로 정의한다.)
---------
7. (Write a macro named mPromptInteger that displays a prompt and inputs an integer from the user.)
(mPromptInteger MACRO prompt, var
 mWrite prompt
 call ReadInt
 mov var,eax
 ENDM 로 정의한다.)
---------
8. (Write a macro named mWriteAt that locates the cursor and writes a string literal to the console window.)
(mWriteAt MACRO x,y,str
 mGotoxy x,y
 mWrite str
 ENDM 로 정의한다.)
---------
9. (Show the expanded code produced by mWriteStr namePrompt.)
(.data
 namePrompt BYTE "",0
 .code
 push edx
 mov edx,OFFSET namePrompt
 call WriteString
 pop edx 로 확장된다.)
---------
10. (Show the expanded code produced by mReadStr customerName.)
(push ecx
 push edx
 mov edx,OFFSET customerName
 mov ecx,SIZEOF customerName
 call ReadString
 pop edx
 pop ecx 로 확장된다.)
---------
11. (Write a macro named mDumpMemx that receives a single parameter, the name of a variable.)
(mDumpMemx MACRO var
 mDumpMem OFFSET var, LENGTHOF var, TYPE var
 ENDM 로 정의한다.)
---------
12. (Show an example of a macro parameter having a default argument initializer.)
(mTest MACRO value:=5
 mov eax,value
 ENDM 과 같이 기본 인자를 설정한다.)
---------
13. (Write a short example that uses the IF, ELSE, and ENDIF directives.)
(IF x EQ 0
 mov eax,1
 ELSE
 mov eax,2
 ENDIF 와 같이 작성한다.)
---------
14. (Write a statement using the IF directive that checks the value of the constant macro parameter Z. If Z is less than zero, display a message during assembly indicating that Z is invalid.)
(IF Z LT 0
 ECHO "Z is invalid"
 ENDIF 로 작성한다.)
---------
15. (Write a short macro that demonstrates the use of the & operator when the macro parameter is embedded in a literal string.)
(mShow MACRO reg
 .data
 tempStr BYTE "&reg",0
 ENDM 과 같이 & 연산자를 사용한다.)
---------
16. (Show the source code generated by the preprocessor when the mLocate macro is expanded by each statement.)
(mLocate -2,20 은 IF 조건에 의해 EXITM 되어 코드가 생성되지 않는다.
 mLocate 10,20 은 정상적으로 BIOS 인터럽트 호출 코드가 생성된다.
 mLocate col,row 는 변수 인자이므로 조건 검사 없이 BIOS 호출 코드가 생성된다.)
---------
